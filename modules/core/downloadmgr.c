/** Arynga CarSync(TM)
 * 2014-2015 Copyrights by Arynga Inc. All rights reserved.
 */

#include "downloadmgr_priv.h"
#include "config.h"
#include "proto.h"
#include "downloaditem.h"
#include "downloader.h"
#include "filetools.h"
#include "logger.h"
#include "imagehandler.h"
#include "strtools.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

static config_Storage* _configStorage = 0;
static DOWNLOADMGR_FINISHED_HANDLER _finishedHandler = 0;
static DOWNLOADMGR_PROGRESS_HANDLER _progressHandler = 0;

static downloaditem_Item* _firstItem = 0;
static char* _updateFilesPath = 0;
static unsigned int _totalDownloadProgress = 0;
static unsigned int _UFsCount = 0;

static int restoreDownloadedItems() {
    int status = 0;
    int diSize = 0;
    int pathSize;
    config_getIValue(_configStorage, DI_SIZE_KEY, &diSize);
    for (int i = 0; i < diSize; ++i) {
        if (!downloaditem_newItemPreppend(&_firstItem)) {
            return 1;
        }
        snprintf(itemKey, ITEM_KEY_SIZE, DI_PATH_KEY_FORMAT, i);
        status |= config_getValue(_configStorage, itemKey, (void**)&_firstItem->path, &pathSize);
    }
    return status;
}

static void markDownloaded(downloaditem_Item* item) {
    free(item->id);
    item->id = 0;
    int diSize = 0;
    config_getIValue(_configStorage, DI_SIZE_KEY, &diSize);
    snprintf(itemKey, ITEM_KEY_SIZE, DI_PATH_KEY_FORMAT, diSize);
    config_setValue(_configStorage, itemKey, item->path, strlen(item->path) + 1);
    ++diSize;
    config_setIValue(_configStorage, DI_SIZE_KEY, diSize);
}

static int cleanupDownloaded() {
    int status = 0;
    // cleanup downloaded items list in storage
    int diSize = 0;
    config_getIValue(_configStorage, DI_SIZE_KEY, &diSize);
    for (int i = 0; i < diSize; ++i) {
        snprintf(itemKey, ITEM_KEY_SIZE, DI_PATH_KEY_FORMAT, i);
        status |= config_removeKey(_configStorage, itemKey);
    }
    status |= config_setIValue(_configStorage, DI_SIZE_KEY, 0);
    // remove all download items
    while (_firstItem) {
        downloaditem_deleteFirstItem(&_firstItem);
    }
    return status;
}

static downloaditem_Item* findUFItem(const char* uuid) {
    downloaditem_Item* item = _firstItem;
    while (item) {
        if (item->path) {
            char*  pos = strstr(item->path, uuid);
            if (pos != 0 && strstr(pos, ".uf")) {
                return item;
            }
        }
        item = item->next;
    }
    return item;
}

static const char* filenameFromUrl(const char* url) {
    const char* filename = strrchr(url, '/');
    if (!filename || strlen(++filename) == 0) {
        LOG(LOGG_WARNING, "Can not find filename in url! Url: %s", url);
        filename = 0;
    }
    return filename;
}

static downloaditem_Item* findDataItem(const char* ufPath, const char* url) {
    downloaditem_Item* item = 0;
    char* ufDir = filetools_getDir(ufPath);
    if (ufDir) {
        const char* filename = filenameFromUrl(url);
        if (filename) {
            item = _firstItem;
            while (item) {
                if (item->path) {
                    char*  pos = strstr(item->path, ufDir);
                    if (pos != 0 && strstr(pos, filename)) {
                        break;
                    }
                }
                item = item->next;
            }
        }
        free(ufDir);
    }
    return item;
}

static int setupUpdateFilesPath(const char* path) {
    free(_updateFilesPath);
    if (path) {
        _updateFilesPath = malloc(strlen(path) + 1);
        if (!_updateFilesPath) {
            LOGM(LOGG_ERROR, "Failed to allocate memory for updateFilesPath!");
            return 1;
        }
        strcpy(_updateFilesPath, path);
    } else {
        _updateFilesPath = 0;
    }
    return 0;
}

static void finalizeDownload(int status) {
    if (status != 0) {
        downloadmgr_cancel();
    } else {
        cleanupDownloaded();
    }
    setupUpdateFilesPath(0);

    if (_finishedHandler) {
        _finishedHandler(status);
    }
}

static int activeDownloads() {
    int activeCount = 0;
    downloaditem_Item* it = _firstItem;
    while (it) {
        if (it->id) {
            ++activeCount;
        }
        it = it->next;
    }
    return activeCount;
}

static int startMetaDownload(proto_UpdateFileItem* updateItem) {
    if (!downloaditem_newItemPreppend(&_firstItem)) {
        return 1;
    }
    // setup destination path
    // updateFilesPath generated by civg never ends with '/'
    _firstItem->path = strtools_sprintNew("%s/%s/%s.uf", _updateFilesPath,
                                          updateItem->uuid, updateItem->uuid);
    if (!_firstItem->path) {
        LOGM(LOGG_ERROR, "Failed to allocate memory for DownloadItem path!");
        return 1;
    }
    _firstItem->type = DOWNLOADITEM_TYPE_META;

    return downloader_downloadItem(updateItem->url, _firstItem->path, &_firstItem->id);
}

static int startDataDownload(const char* ufPath, const char* url) {
    if (!downloaditem_newItemPreppend(&_firstItem)) {
        return 1;
    }
    // setup destination path
    char* ufDir = filetools_getDir(ufPath);
    if (ufDir) {
        const char* filename = filenameFromUrl(url);
        if (filename) {
            _firstItem->path = strtools_sprintNew("%s/%s/%s", ufDir, IMAGEHANDLER_IMAGES_SUBDIR, filename);
            if (!_firstItem->path) {
                LOGM(LOGG_ERROR, "Failed to allocate memory for DownloadItem path!");
            }
        }
        free(ufDir);
    }
    if (!_firstItem->path) {
        return 1;
    }
    _firstItem->type = DOWNLOADITEM_TYPE_DATA;

    return downloader_downloadItem(url, _firstItem->path, &_firstItem->id);
}

static int extractUFFile(const char* path) {
    int status = 1;
    char* dirPath = filetools_getDir(path);
    if (dirPath) {
        status = filetools_extractTar(path, dirPath);
        free(dirPath);
    }
    return status;
}

static proto_UpdateFileMeta* unpackMetaFile(const char* ufPath) {
    proto_UpdateFileMeta* ufMeta = 0;
    char* ufDir = filetools_getDir(ufPath);
    if (ufDir) {
        ufMeta = proto_unpackMetaFile(ufDir);
        free(ufDir);
    }
    return ufMeta;
}

static void finishedItemHandler(const char* id, int status) {
    downloaditem_Item* item = downloaditem_findItemById(_firstItem, id);
    if (item) {
        if (status == 0) {
            // mark item as downloaded
            markDownloaded(item);

            if (item->type == DOWNLOADITEM_TYPE_META) {
                // check associated data url and start download
                if (extractUFFile(item->path) == 0) {
                    proto_UpdateFileMeta* ufMeta = unpackMetaFile(item->path);
                    if (ufMeta) {
                        if (startDataDownload(item->path, ufMeta->url) != 0) {
                            finalizeDownload(1);
                        }
                        car_sync__proto__release_package__update_file_meta__free_unpacked(ufMeta, NULL);
                    } else {
                        finalizeDownload(1);
                    }
                } else {
                    finalizeDownload(1);
                }
            } else {
                if (activeDownloads() == 0) {
                    LOGM(LOGG_DEBUG, "Finished downloading all update files.");
                    finalizeDownload(0);
                }
            }
        } else {
            LOG(LOGG_WARNING, "Failed to download file! Id: %s; Path: %s; Status: %d", id, item->path, status);
            finalizeDownload(1);
        }
    } else {
        LOG(LOGG_WARNING, "Unrecognized download finished! Id:%s; Status:%d", id, status);
    }
}

static void itemProgressHandler(const char* id, unsigned int percentage) {
    downloaditem_Item* item = downloaditem_findItemById(_firstItem, id);

    if (item && item->type != DOWNLOADITEM_TYPE_META) {
        _totalDownloadProgress-=item->progress;
        item->progress=percentage;
        _totalDownloadProgress+=item->progress;
        if(_progressHandler) {
            if(0!=_UFsCount) {
                _progressHandler((unsigned int)(_totalDownloadProgress/_UFsCount));
                LOG(LOGG_DEBUG, "Download progress for ID %s: %u (%u for current file, total %u files)", id, _totalDownloadProgress/_UFsCount, _totalDownloadProgress, _UFsCount);
            } /*else {
                _progressHandler(100);
            }*/
        }
    }
}

static int preprareDownload(const char* updateFilesPath) {
    if (_firstItem) {
        LOGM(LOGG_ERROR, "Multiple updates download not supported!");
        return 1;
    }
    if (!updateFilesPath || strlen(updateFilesPath) == 0) {
        LOGM(LOGG_ERROR, "Empty update files path!");
        return 1;
    } else {
        return setupUpdateFilesPath(updateFilesPath);
    }
}

int downloadmgr_downloadUFs(const proto_UpdateDescriptor* updateDescriptor,
                            const char* updateFilesPath) {
    if (preprareDownload(updateFilesPath) != 0) {
        return 1;
    }
    _totalDownloadProgress=0;
    _UFsCount = updateDescriptor->n_updates;
    for (unsigned int i = 0; i < updateDescriptor->n_updates; ++i) {
        if (updateDescriptor->updates[i] &&
                updateDescriptor->updates[i]->url) {
            if (startMetaDownload(updateDescriptor->updates[i]) != 0) {
                LOG(LOGG_WARNING, "Failed to start meta files download. UFItem url: %s", updateDescriptor->updates[i]->url);
                downloadmgr_cancel();
                setupUpdateFilesPath(0);
                return 1;
            }
        } else {
            LOGM(LOGG_ERROR, "Failed to start meta files download. UFItem details missing.");
            return 1;
        }
    }
    if (activeDownloads() == 0) {
        LOGM(LOGG_DEBUG, "Nothing to download.");
        finalizeDownload(0);
    }
    return 0;
}

int downloadmgr_resume(const proto_UpdateDescriptor* updateDescriptor,
                       const char* updateFilesPath) {
    if (preprareDownload(updateFilesPath) != 0) {
        return 1;
    }
    // check what has been already downloaded
    if (restoreDownloadedItems() != 0) {
        // cleanup restoreDownloadedItems() remnants
        downloadmgr_cancel();
        LOGM(LOGG_WARNING, "Could not restore list of downloaded files! Starting download from the beginning.");
        return downloadmgr_downloadUFs(updateDescriptor, updateFilesPath);
    }
    downloaditem_Item* metaItem;
    downloaditem_Item* dataItem;
    int status = 0;
    for (unsigned int i = 0; i < updateDescriptor->n_updates; ++i) {
        status = 1;
        // first find if metaItem is already downloaded or not
        metaItem = findUFItem(updateDescriptor->updates[i]->uuid);
        if (metaItem) {
            // metaItem already downloaded
            // check associated data and try to resume
            if (extractUFFile(metaItem->path) != 0) {
                break;
            }
            proto_UpdateFileMeta* ufMeta = unpackMetaFile(metaItem->path);
            if (ufMeta) {
                // find if dataItem is already downloaded or not
                dataItem = findDataItem(metaItem->path, ufMeta->url);
                if (dataItem) {
                    // dataItem already downloaded - just set status OK
                    status = 0;
                } else {
                    status = startDataDownload(metaItem->path, ufMeta->url);
                }
                car_sync__proto__release_package__update_file_meta__free_unpacked(ufMeta, NULL);
                if (status != 0) {
                    break;
                }
            } else {
                break;
            }
        } else {
            status = startMetaDownload(updateDescriptor->updates[i]);
            if (status != 0) {
                break;
            }
        }
    }
    if (status != 0) {
        downloadmgr_cancel();
        setupUpdateFilesPath(0);
    } else if (activeDownloads() == 0) {
        LOGM(LOGG_DEBUG, "All update files already downloaded.");
        finalizeDownload(0);
    }

    return status;
}

int downloadmgr_cancel() {
    int status = 0;

    // cancel all active downloads
    for (downloaditem_Item* item = _firstItem; item != 0; item = item->next) {
        if (item->id) {
            status |= downloader_cancel(item->id);
        }
    }

    status |= cleanupDownloaded();

    return status;
}

int downloadmgr_init() {
    if (_configStorage) {
        LOGM(LOGG_ERROR, "Doubled DownloadMgr initialization!");
        return 1;
    }

    // basic setup
    _configStorage = config_newStorage(DOWNLOADMGR_STORAGE_ID);
    if (!_configStorage) {
        LOGM(LOGG_ERROR, "Can not open config storage!");
        return 1;
    }
    if (downloader_init() != 0) {
        LOGM(LOGG_ERROR, "Failed to initialize downloader!");
        downloadmgr_cleanup();
        return 1;
    }
    downloader_setFinishedHandler(finishedItemHandler);
    downloader_setProgressHandler(itemProgressHandler);
    return 0;
}

void downloadmgr_cleanup() {
    if (_configStorage) {
        _finishedHandler = 0;
        _progressHandler = 0;
        downloadmgr_cancel();
        downloader_cleanup();

        setupUpdateFilesPath(0);
        config_deleteStorage(_configStorage);
        _configStorage = 0;
    }
}

void downloadmgr_setFinishedHandler(DOWNLOADMGR_FINISHED_HANDLER handler) {
    _finishedHandler = handler;
}

void downloadmgr_setProgressHandler(DOWNLOADMGR_PROGRESS_HANDLER handler) {
    _progressHandler = handler;
}
